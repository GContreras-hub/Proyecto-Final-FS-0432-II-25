{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simulaci\u00f3n de Tr\u00e1fico IDM Bienvenido a la documentaci\u00f3n del proyecto. Este sitio documenta la simulaci\u00f3n de tr\u00e1fico circular usando el modelo IDM, implementada en Python con el paradigma orientado a objetos. En la secci\u00f3n API pod\u00e9s ver la documentaci\u00f3n generada autom\u00e1ticamente a partir de los docstrings del c\u00f3digo.","title":"Inicio"},{"location":"#simulacion-de-trafico-idm","text":"Bienvenido a la documentaci\u00f3n del proyecto. Este sitio documenta la simulaci\u00f3n de tr\u00e1fico circular usando el modelo IDM, implementada en Python con el paradigma orientado a objetos. En la secci\u00f3n API pod\u00e9s ver la documentaci\u00f3n generada autom\u00e1ticamente a partir de los docstrings del c\u00f3digo.","title":"Simulaci\u00f3n de Tr\u00e1fico IDM"},{"location":"api/simulacion/","text":"Clase TrafficSimulation A continuaci\u00f3n se documenta autom\u00e1ticamente la clase principal. Simulaci\u00f3n de tr\u00e1fico vehicular en una carretera circular utilizando el modelo IDM (Intelligent Driver Model) y eventos de frenado peri\u00f3dico del veh\u00edculo l\u00edder. Esta clase encapsula toda la l\u00f3gica del sistema: par\u00e1metros del modelo, estado din\u00e1mico, reglas de actualizaci\u00f3n, detecci\u00f3n de frenados, mecanismo anti-colisi\u00f3n y visualizaci\u00f3n animada. La simulaci\u00f3n contiene N veh\u00edculos distribuidos sobre un circuito circular, donde el veh\u00edculo 0 act\u00faa como l\u00edder y se detiene peri\u00f3dicamente seg\u00fan un patr\u00f3n configurable. Source code in simulacionPoo.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class TrafficSimulation : \"\"\" Simulaci\u00f3n de tr\u00e1fico vehicular en una carretera circular utilizando el modelo IDM (Intelligent Driver Model) y eventos de frenado peri\u00f3dico del veh\u00edculo l\u00edder. Esta clase encapsula toda la l\u00f3gica del sistema: par\u00e1metros del modelo, estado din\u00e1mico, reglas de actualizaci\u00f3n, detecci\u00f3n de frenados, mecanismo anti-colisi\u00f3n y visualizaci\u00f3n animada. La simulaci\u00f3n contiene N veh\u00edculos distribuidos sobre un circuito circular, donde el veh\u00edculo 0 act\u00faa como l\u00edder y se detiene peri\u00f3dicamente seg\u00fan un patr\u00f3n configurable. \"\"\" def __init__ ( self ): \"\"\" Inicializa los par\u00e1metros f\u00edsicos, modelo IDM, configuraci\u00f3n de frenazos del l\u00edder y el estado inicial de posiciones y velocidades. \"\"\" # Par\u00e1metros Globales self . N = 22 \"\"\"int: N\u00famero total de veh\u00edculos en el circuito.\"\"\" self . CIRC = 230.0 \"\"\"float: Longitud total del circuito en metros.\"\"\" self . DT = 0.05 \"\"\"float: Paso de tiempo de integraci\u00f3n (Euler).\"\"\" self . SIM_TIME = 1200.0 \"\"\"float: Tiempo total de simulaci\u00f3n en segundos.\"\"\" # Par\u00e1metros F\u00edsicos self . L_VEHICLE = 4.0 \"\"\"float: Longitud de cada veh\u00edculo en metros.\"\"\" self . S0 = 2.0 \"\"\"float: Distancia m\u00ednima permisible (jam distance).\"\"\" # Modelo IDM self . V0 = 10.0 \"\"\"float: Velocidad deseada.\"\"\" self . A_MAX = 1.0 \"\"\"float: Aceleraci\u00f3n m\u00e1xima permitida.\"\"\" self . B_DECEL = 4.0 \"\"\"float: Desaceleraci\u00f3n c\u00f3moda.\"\"\" self . T_HEADWAY = 1.6 \"\"\"float: Tiempo de separaci\u00f3n deseado entre veh\u00edculos.\"\"\" # Eventos de parada del l\u00edder self . STOP_DURATION = 2.0 \"\"\"float: Duraci\u00f3n de cada frenazo del l\u00edder.\"\"\" self . FIRST_STOP = 2.0 \"\"\"float: Momento en que ocurre el primer frenazo.\"\"\" self . REPEAT_INTERVAL = 10.0 \"\"\"float: Intervalo entre frenazos consecutivos.\"\"\" # Estado inicial self . s = np . linspace ( 0 , self . CIRC , self . N , endpoint = False ) \"\"\"np.ndarray: Posiciones iniciales sobre el circuito circular.\"\"\" self . v = np . ones ( self . N ) * self . V0 \"\"\"np.ndarray: Velocidades iniciales.\"\"\" # Visualizaci\u00f3n self . fig , self . ax = None , None # M\u00c9TODOS DEL MODELO def get_gap ( self , i , s_curr ): \"\"\" Calcula la distancia disponible entre el veh\u00edculo `i` y su l\u00edder. Args: i (int): \u00cdndice del veh\u00edculo. s_curr (np.ndarray): Vector actual de posiciones. Returns: float: Distancia libre efectiva al veh\u00edculo de adelante. \"\"\" leader_idx = ( i - 1 + self . N ) % self . N dist = s_curr [ leader_idx ] - s_curr [ i ] if dist < 0 : dist += self . CIRC return dist - self . L_VEHICLE def idm_accel ( self , v_curr , v_leader , gap ): \"\"\" Calcula la aceleraci\u00f3n seg\u00fan el modelo IDM (Intelligent Driver Model). Args: v_curr (float): Velocidad del veh\u00edculo actual. v_leader (float): Velocidad del veh\u00edculo l\u00edder inmediato. gap (float): Distancia libre al l\u00edder. Returns: float: Aceleraci\u00f3n resultante seg\u00fan el modelo. \"\"\" delta_v = v_curr - v_leader s_star = self . S0 + max ( 0.0 , v_curr * self . T_HEADWAY + ( v_curr * delta_v ) / ( 2 * math . sqrt ( self . A_MAX * self . B_DECEL )) ) effective_gap = max ( 0.01 , gap ) accel = self . A_MAX * ( 1 - ( v_curr / self . V0 ) ** 4 - ( s_star / effective_gap ) ** 2 ) return accel def leader_stopped ( self , t ): \"\"\" Determina si el veh\u00edculo l\u00edder debe estar detenido en el tiempo `t`. Los frenazos ocurren en: - FIRST_STOP - FIRST_STOP + REPEAT_INTERVAL - FIRST_STOP + 2*REPEAT_INTERVAL etc. Y duran STOP_DURATION segundos cada uno. Args: t (float): Tiempo actual de la simulaci\u00f3n. Returns: bool: True si el l\u00edder debe estar frenando o detenido. \"\"\" time_since_start = t - self . FIRST_STOP if time_since_start >= 0 : cycle_pos = time_since_start % self . REPEAT_INTERVAL return cycle_pos < self . STOP_DURATION return False def run_step ( self , t ): \"\"\" Ejecuta un paso de simulaci\u00f3n: calcula aceleraciones, actualiza velocidades y posiciones, y aplica la regla anti-colisi\u00f3n. Args: t (float): Tiempo actual. \"\"\" s_new = np . copy ( self . s ) v_new = np . copy ( self . v ) accel = np . zeros ( self . N ) p0_is_stopped = self . leader_stopped ( t ) # Calcular aceleraciones for i in range ( self . N ): if i == 0 : if p0_is_stopped : if self . v [ i ] > 0 : accel [ i ] = - 10.0 else : accel [ i ] = 0.0 v_new [ i ] = 0.0 else : accel [ i ] = self . A_MAX * ( 1 - ( self . v [ i ] / self . V0 ) ** 4 ) else : leader_idx = ( i - 1 + self . N ) % self . N gap = self . get_gap ( i , self . s ) accel [ i ] = self . idm_accel ( self . v [ i ], self . v [ leader_idx ], gap ) # Actualizar posiciones y velocidades (Euler) for i in range ( self . N ): if i == 0 and p0_is_stopped and v_new [ i ] == 0 : continue v_new [ i ] = max ( 0.0 , self . v [ i ] + accel [ i ] * self . DT ) s_new [ i ] = ( self . s [ i ] + v_new [ i ] * self . DT ) % self . CIRC # Regla anti-colisi\u00f3n if i != 0 : gap = self . get_gap ( i , self . s ) if ( v_new [ i ] * self . DT ) > ( gap - 0.5 ): v_new [ i ] = max ( 0.0 , ( gap - 0.5 ) / self . DT ) s_new [ i ] = ( self . s [ i ] + v_new [ i ] * self . DT ) % self . CIRC self . s = s_new self . v = v_new # VISUALIZACI\u00d3N def setup_draw ( self ): \"\"\" Inicializa la ventana y ejes de Matplotlib para la animaci\u00f3n. \"\"\" plt . ion () self . fig , self . ax = plt . subplots ( figsize = ( 7 , 7 )) def draw ( self , t ): \"\"\" Dibuja el estado actual de la simulaci\u00f3n: posiciones de veh\u00edculos, circuito circular y t\u00edtulo con tiempo. Args: t (float): Tiempo actual de la simulaci\u00f3n. \"\"\" R = self . CIRC / ( 2 * np . pi ) self . ax . clear () self . ax . set_box_aspect ( 1 ) self . ax . set_xlim ( - R * 1.3 , R * 1.3 ) self . ax . set_ylim ( - R * 1.3 , R * 1.3 ) self . ax . axis ( 'off' ) circle = plt . Circle (( 0 , 0 ), R , color = 'gray' , fill = False , linestyle = '--' , linewidth = 1.5 ) self . ax . add_artist ( circle ) angles = self . s / R X = R * np . cos ( angles ) Y = R * np . sin ( angles ) colors = [ 'blue' if i == 0 else '#d62728' for i in range ( self . N )] self . ax . scatter ( X , Y , s = 100 , c = colors , edgecolors = 'black' , zorder = 10 ) self . ax . set_title ( f \"Simulaci\u00f3n de Tr\u00e1fico \\n Tiempo: { t : .1f } s\" , fontsize = 14 ) plt . pause ( 0.001 ) # LOOP PRINCIPAL def run ( self ): \"\"\" Ejecuta el ciclo principal de la simulaci\u00f3n con visualizaci\u00f3n animada. - Inicializa la figura - Itera sobre la din\u00e1mica - Dibuja cada cierto n\u00famero de pasos - Finaliza mostrando la animaci\u00f3n detenida \"\"\" self . setup_draw () t = 0.0 print ( \"Iniciando simulaci\u00f3n...\" ) print ( f \"P0 frena a los { self . FIRST_STOP } s y cada { self . REPEAT_INTERVAL } s.\" ) while t < self . SIM_TIME : self . run_step ( t ) if int ( t / self . DT ) % 2 == 0 : self . draw ( t ) t += self . DT plt . ioff () plt . show () A_MAX = 1.0 instance-attribute float: Aceleraci\u00f3n m\u00e1xima permitida. B_DECEL = 4.0 instance-attribute float: Desaceleraci\u00f3n c\u00f3moda. CIRC = 230.0 instance-attribute float: Longitud total del circuito en metros. DT = 0.05 instance-attribute float: Paso de tiempo de integraci\u00f3n (Euler). FIRST_STOP = 2.0 instance-attribute float: Momento en que ocurre el primer frenazo. L_VEHICLE = 4.0 instance-attribute float: Longitud de cada veh\u00edculo en metros. N = 22 instance-attribute int: N\u00famero total de veh\u00edculos en el circuito. REPEAT_INTERVAL = 10.0 instance-attribute float: Intervalo entre frenazos consecutivos. S0 = 2.0 instance-attribute float: Distancia m\u00ednima permisible (jam distance). SIM_TIME = 1200.0 instance-attribute float: Tiempo total de simulaci\u00f3n en segundos. STOP_DURATION = 2.0 instance-attribute float: Duraci\u00f3n de cada frenazo del l\u00edder. T_HEADWAY = 1.6 instance-attribute float: Tiempo de separaci\u00f3n deseado entre veh\u00edculos. V0 = 10.0 instance-attribute float: Velocidad deseada. s = np . linspace ( 0 , self . CIRC , self . N , endpoint = False ) instance-attribute np.ndarray: Posiciones iniciales sobre el circuito circular. v = np . ones ( self . N ) * self . V0 instance-attribute np.ndarray: Velocidades iniciales. __init__ () Inicializa los par\u00e1metros f\u00edsicos, modelo IDM, configuraci\u00f3n de frenazos del l\u00edder y el estado inicial de posiciones y velocidades. Source code in simulacionPoo.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __init__ ( self ): \"\"\" Inicializa los par\u00e1metros f\u00edsicos, modelo IDM, configuraci\u00f3n de frenazos del l\u00edder y el estado inicial de posiciones y velocidades. \"\"\" # Par\u00e1metros Globales self . N = 22 \"\"\"int: N\u00famero total de veh\u00edculos en el circuito.\"\"\" self . CIRC = 230.0 \"\"\"float: Longitud total del circuito en metros.\"\"\" self . DT = 0.05 \"\"\"float: Paso de tiempo de integraci\u00f3n (Euler).\"\"\" self . SIM_TIME = 1200.0 \"\"\"float: Tiempo total de simulaci\u00f3n en segundos.\"\"\" # Par\u00e1metros F\u00edsicos self . L_VEHICLE = 4.0 \"\"\"float: Longitud de cada veh\u00edculo en metros.\"\"\" self . S0 = 2.0 \"\"\"float: Distancia m\u00ednima permisible (jam distance).\"\"\" # Modelo IDM self . V0 = 10.0 \"\"\"float: Velocidad deseada.\"\"\" self . A_MAX = 1.0 \"\"\"float: Aceleraci\u00f3n m\u00e1xima permitida.\"\"\" self . B_DECEL = 4.0 \"\"\"float: Desaceleraci\u00f3n c\u00f3moda.\"\"\" self . T_HEADWAY = 1.6 \"\"\"float: Tiempo de separaci\u00f3n deseado entre veh\u00edculos.\"\"\" # Eventos de parada del l\u00edder self . STOP_DURATION = 2.0 \"\"\"float: Duraci\u00f3n de cada frenazo del l\u00edder.\"\"\" self . FIRST_STOP = 2.0 \"\"\"float: Momento en que ocurre el primer frenazo.\"\"\" self . REPEAT_INTERVAL = 10.0 \"\"\"float: Intervalo entre frenazos consecutivos.\"\"\" # Estado inicial self . s = np . linspace ( 0 , self . CIRC , self . N , endpoint = False ) \"\"\"np.ndarray: Posiciones iniciales sobre el circuito circular.\"\"\" self . v = np . ones ( self . N ) * self . V0 \"\"\"np.ndarray: Velocidades iniciales.\"\"\" # Visualizaci\u00f3n self . fig , self . ax = None , None draw ( t ) Dibuja el estado actual de la simulaci\u00f3n: posiciones de veh\u00edculos, circuito circular y t\u00edtulo con tiempo. Parameters: t ( float ) \u2013 Tiempo actual de la simulaci\u00f3n. Source code in simulacionPoo.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def draw ( self , t ): \"\"\" Dibuja el estado actual de la simulaci\u00f3n: posiciones de veh\u00edculos, circuito circular y t\u00edtulo con tiempo. Args: t (float): Tiempo actual de la simulaci\u00f3n. \"\"\" R = self . CIRC / ( 2 * np . pi ) self . ax . clear () self . ax . set_box_aspect ( 1 ) self . ax . set_xlim ( - R * 1.3 , R * 1.3 ) self . ax . set_ylim ( - R * 1.3 , R * 1.3 ) self . ax . axis ( 'off' ) circle = plt . Circle (( 0 , 0 ), R , color = 'gray' , fill = False , linestyle = '--' , linewidth = 1.5 ) self . ax . add_artist ( circle ) angles = self . s / R X = R * np . cos ( angles ) Y = R * np . sin ( angles ) colors = [ 'blue' if i == 0 else '#d62728' for i in range ( self . N )] self . ax . scatter ( X , Y , s = 100 , c = colors , edgecolors = 'black' , zorder = 10 ) self . ax . set_title ( f \"Simulaci\u00f3n de Tr\u00e1fico \\n Tiempo: { t : .1f } s\" , fontsize = 14 ) plt . pause ( 0.001 ) get_gap ( i , s_curr ) Calcula la distancia disponible entre el veh\u00edculo i y su l\u00edder. Parameters: i ( int ) \u2013 \u00cdndice del veh\u00edculo. s_curr ( ndarray ) \u2013 Vector actual de posiciones. Returns: float \u2013 Distancia libre efectiva al veh\u00edculo de adelante. Source code in simulacionPoo.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_gap ( self , i , s_curr ): \"\"\" Calcula la distancia disponible entre el veh\u00edculo `i` y su l\u00edder. Args: i (int): \u00cdndice del veh\u00edculo. s_curr (np.ndarray): Vector actual de posiciones. Returns: float: Distancia libre efectiva al veh\u00edculo de adelante. \"\"\" leader_idx = ( i - 1 + self . N ) % self . N dist = s_curr [ leader_idx ] - s_curr [ i ] if dist < 0 : dist += self . CIRC return dist - self . L_VEHICLE idm_accel ( v_curr , v_leader , gap ) Calcula la aceleraci\u00f3n seg\u00fan el modelo IDM (Intelligent Driver Model). Parameters: v_curr ( float ) \u2013 Velocidad del veh\u00edculo actual. v_leader ( float ) \u2013 Velocidad del veh\u00edculo l\u00edder inmediato. gap ( float ) \u2013 Distancia libre al l\u00edder. Returns: float \u2013 Aceleraci\u00f3n resultante seg\u00fan el modelo. Source code in simulacionPoo.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def idm_accel ( self , v_curr , v_leader , gap ): \"\"\" Calcula la aceleraci\u00f3n seg\u00fan el modelo IDM (Intelligent Driver Model). Args: v_curr (float): Velocidad del veh\u00edculo actual. v_leader (float): Velocidad del veh\u00edculo l\u00edder inmediato. gap (float): Distancia libre al l\u00edder. Returns: float: Aceleraci\u00f3n resultante seg\u00fan el modelo. \"\"\" delta_v = v_curr - v_leader s_star = self . S0 + max ( 0.0 , v_curr * self . T_HEADWAY + ( v_curr * delta_v ) / ( 2 * math . sqrt ( self . A_MAX * self . B_DECEL )) ) effective_gap = max ( 0.01 , gap ) accel = self . A_MAX * ( 1 - ( v_curr / self . V0 ) ** 4 - ( s_star / effective_gap ) ** 2 ) return accel leader_stopped ( t ) Determina si el veh\u00edculo l\u00edder debe estar detenido en el tiempo t . Los frenazos ocurren en: - FIRST_STOP - FIRST_STOP + REPEAT_INTERVAL - FIRST_STOP + 2*REPEAT_INTERVAL etc. Y duran STOP_DURATION segundos cada uno. Parameters: t ( float ) \u2013 Tiempo actual de la simulaci\u00f3n. Returns: bool \u2013 True si el l\u00edder debe estar frenando o detenido. Source code in simulacionPoo.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def leader_stopped ( self , t ): \"\"\" Determina si el veh\u00edculo l\u00edder debe estar detenido en el tiempo `t`. Los frenazos ocurren en: - FIRST_STOP - FIRST_STOP + REPEAT_INTERVAL - FIRST_STOP + 2*REPEAT_INTERVAL etc. Y duran STOP_DURATION segundos cada uno. Args: t (float): Tiempo actual de la simulaci\u00f3n. Returns: bool: True si el l\u00edder debe estar frenando o detenido. \"\"\" time_since_start = t - self . FIRST_STOP if time_since_start >= 0 : cycle_pos = time_since_start % self . REPEAT_INTERVAL return cycle_pos < self . STOP_DURATION return False run () Ejecuta el ciclo principal de la simulaci\u00f3n con visualizaci\u00f3n animada. Inicializa la figura Itera sobre la din\u00e1mica Dibuja cada cierto n\u00famero de pasos Finaliza mostrando la animaci\u00f3n detenida Source code in simulacionPoo.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def run ( self ): \"\"\" Ejecuta el ciclo principal de la simulaci\u00f3n con visualizaci\u00f3n animada. - Inicializa la figura - Itera sobre la din\u00e1mica - Dibuja cada cierto n\u00famero de pasos - Finaliza mostrando la animaci\u00f3n detenida \"\"\" self . setup_draw () t = 0.0 print ( \"Iniciando simulaci\u00f3n...\" ) print ( f \"P0 frena a los { self . FIRST_STOP } s y cada { self . REPEAT_INTERVAL } s.\" ) while t < self . SIM_TIME : self . run_step ( t ) if int ( t / self . DT ) % 2 == 0 : self . draw ( t ) t += self . DT plt . ioff () plt . show () run_step ( t ) Ejecuta un paso de simulaci\u00f3n: calcula aceleraciones, actualiza velocidades y posiciones, y aplica la regla anti-colisi\u00f3n. Parameters: t ( float ) \u2013 Tiempo actual. Source code in simulacionPoo.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def run_step ( self , t ): \"\"\" Ejecuta un paso de simulaci\u00f3n: calcula aceleraciones, actualiza velocidades y posiciones, y aplica la regla anti-colisi\u00f3n. Args: t (float): Tiempo actual. \"\"\" s_new = np . copy ( self . s ) v_new = np . copy ( self . v ) accel = np . zeros ( self . N ) p0_is_stopped = self . leader_stopped ( t ) # Calcular aceleraciones for i in range ( self . N ): if i == 0 : if p0_is_stopped : if self . v [ i ] > 0 : accel [ i ] = - 10.0 else : accel [ i ] = 0.0 v_new [ i ] = 0.0 else : accel [ i ] = self . A_MAX * ( 1 - ( self . v [ i ] / self . V0 ) ** 4 ) else : leader_idx = ( i - 1 + self . N ) % self . N gap = self . get_gap ( i , self . s ) accel [ i ] = self . idm_accel ( self . v [ i ], self . v [ leader_idx ], gap ) # Actualizar posiciones y velocidades (Euler) for i in range ( self . N ): if i == 0 and p0_is_stopped and v_new [ i ] == 0 : continue v_new [ i ] = max ( 0.0 , self . v [ i ] + accel [ i ] * self . DT ) s_new [ i ] = ( self . s [ i ] + v_new [ i ] * self . DT ) % self . CIRC # Regla anti-colisi\u00f3n if i != 0 : gap = self . get_gap ( i , self . s ) if ( v_new [ i ] * self . DT ) > ( gap - 0.5 ): v_new [ i ] = max ( 0.0 , ( gap - 0.5 ) / self . DT ) s_new [ i ] = ( self . s [ i ] + v_new [ i ] * self . DT ) % self . CIRC self . s = s_new self . v = v_new setup_draw () Inicializa la ventana y ejes de Matplotlib para la animaci\u00f3n. Source code in simulacionPoo.py 199 200 201 202 203 204 def setup_draw ( self ): \"\"\" Inicializa la ventana y ejes de Matplotlib para la animaci\u00f3n. \"\"\" plt . ion () self . fig , self . ax = plt . subplots ( figsize = ( 7 , 7 ))","title":"Simulaci\u00f3n"},{"location":"api/simulacion/#clase-trafficsimulation","text":"A continuaci\u00f3n se documenta autom\u00e1ticamente la clase principal. Simulaci\u00f3n de tr\u00e1fico vehicular en una carretera circular utilizando el modelo IDM (Intelligent Driver Model) y eventos de frenado peri\u00f3dico del veh\u00edculo l\u00edder. Esta clase encapsula toda la l\u00f3gica del sistema: par\u00e1metros del modelo, estado din\u00e1mico, reglas de actualizaci\u00f3n, detecci\u00f3n de frenados, mecanismo anti-colisi\u00f3n y visualizaci\u00f3n animada. La simulaci\u00f3n contiene N veh\u00edculos distribuidos sobre un circuito circular, donde el veh\u00edculo 0 act\u00faa como l\u00edder y se detiene peri\u00f3dicamente seg\u00fan un patr\u00f3n configurable. Source code in simulacionPoo.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 class TrafficSimulation : \"\"\" Simulaci\u00f3n de tr\u00e1fico vehicular en una carretera circular utilizando el modelo IDM (Intelligent Driver Model) y eventos de frenado peri\u00f3dico del veh\u00edculo l\u00edder. Esta clase encapsula toda la l\u00f3gica del sistema: par\u00e1metros del modelo, estado din\u00e1mico, reglas de actualizaci\u00f3n, detecci\u00f3n de frenados, mecanismo anti-colisi\u00f3n y visualizaci\u00f3n animada. La simulaci\u00f3n contiene N veh\u00edculos distribuidos sobre un circuito circular, donde el veh\u00edculo 0 act\u00faa como l\u00edder y se detiene peri\u00f3dicamente seg\u00fan un patr\u00f3n configurable. \"\"\" def __init__ ( self ): \"\"\" Inicializa los par\u00e1metros f\u00edsicos, modelo IDM, configuraci\u00f3n de frenazos del l\u00edder y el estado inicial de posiciones y velocidades. \"\"\" # Par\u00e1metros Globales self . N = 22 \"\"\"int: N\u00famero total de veh\u00edculos en el circuito.\"\"\" self . CIRC = 230.0 \"\"\"float: Longitud total del circuito en metros.\"\"\" self . DT = 0.05 \"\"\"float: Paso de tiempo de integraci\u00f3n (Euler).\"\"\" self . SIM_TIME = 1200.0 \"\"\"float: Tiempo total de simulaci\u00f3n en segundos.\"\"\" # Par\u00e1metros F\u00edsicos self . L_VEHICLE = 4.0 \"\"\"float: Longitud de cada veh\u00edculo en metros.\"\"\" self . S0 = 2.0 \"\"\"float: Distancia m\u00ednima permisible (jam distance).\"\"\" # Modelo IDM self . V0 = 10.0 \"\"\"float: Velocidad deseada.\"\"\" self . A_MAX = 1.0 \"\"\"float: Aceleraci\u00f3n m\u00e1xima permitida.\"\"\" self . B_DECEL = 4.0 \"\"\"float: Desaceleraci\u00f3n c\u00f3moda.\"\"\" self . T_HEADWAY = 1.6 \"\"\"float: Tiempo de separaci\u00f3n deseado entre veh\u00edculos.\"\"\" # Eventos de parada del l\u00edder self . STOP_DURATION = 2.0 \"\"\"float: Duraci\u00f3n de cada frenazo del l\u00edder.\"\"\" self . FIRST_STOP = 2.0 \"\"\"float: Momento en que ocurre el primer frenazo.\"\"\" self . REPEAT_INTERVAL = 10.0 \"\"\"float: Intervalo entre frenazos consecutivos.\"\"\" # Estado inicial self . s = np . linspace ( 0 , self . CIRC , self . N , endpoint = False ) \"\"\"np.ndarray: Posiciones iniciales sobre el circuito circular.\"\"\" self . v = np . ones ( self . N ) * self . V0 \"\"\"np.ndarray: Velocidades iniciales.\"\"\" # Visualizaci\u00f3n self . fig , self . ax = None , None # M\u00c9TODOS DEL MODELO def get_gap ( self , i , s_curr ): \"\"\" Calcula la distancia disponible entre el veh\u00edculo `i` y su l\u00edder. Args: i (int): \u00cdndice del veh\u00edculo. s_curr (np.ndarray): Vector actual de posiciones. Returns: float: Distancia libre efectiva al veh\u00edculo de adelante. \"\"\" leader_idx = ( i - 1 + self . N ) % self . N dist = s_curr [ leader_idx ] - s_curr [ i ] if dist < 0 : dist += self . CIRC return dist - self . L_VEHICLE def idm_accel ( self , v_curr , v_leader , gap ): \"\"\" Calcula la aceleraci\u00f3n seg\u00fan el modelo IDM (Intelligent Driver Model). Args: v_curr (float): Velocidad del veh\u00edculo actual. v_leader (float): Velocidad del veh\u00edculo l\u00edder inmediato. gap (float): Distancia libre al l\u00edder. Returns: float: Aceleraci\u00f3n resultante seg\u00fan el modelo. \"\"\" delta_v = v_curr - v_leader s_star = self . S0 + max ( 0.0 , v_curr * self . T_HEADWAY + ( v_curr * delta_v ) / ( 2 * math . sqrt ( self . A_MAX * self . B_DECEL )) ) effective_gap = max ( 0.01 , gap ) accel = self . A_MAX * ( 1 - ( v_curr / self . V0 ) ** 4 - ( s_star / effective_gap ) ** 2 ) return accel def leader_stopped ( self , t ): \"\"\" Determina si el veh\u00edculo l\u00edder debe estar detenido en el tiempo `t`. Los frenazos ocurren en: - FIRST_STOP - FIRST_STOP + REPEAT_INTERVAL - FIRST_STOP + 2*REPEAT_INTERVAL etc. Y duran STOP_DURATION segundos cada uno. Args: t (float): Tiempo actual de la simulaci\u00f3n. Returns: bool: True si el l\u00edder debe estar frenando o detenido. \"\"\" time_since_start = t - self . FIRST_STOP if time_since_start >= 0 : cycle_pos = time_since_start % self . REPEAT_INTERVAL return cycle_pos < self . STOP_DURATION return False def run_step ( self , t ): \"\"\" Ejecuta un paso de simulaci\u00f3n: calcula aceleraciones, actualiza velocidades y posiciones, y aplica la regla anti-colisi\u00f3n. Args: t (float): Tiempo actual. \"\"\" s_new = np . copy ( self . s ) v_new = np . copy ( self . v ) accel = np . zeros ( self . N ) p0_is_stopped = self . leader_stopped ( t ) # Calcular aceleraciones for i in range ( self . N ): if i == 0 : if p0_is_stopped : if self . v [ i ] > 0 : accel [ i ] = - 10.0 else : accel [ i ] = 0.0 v_new [ i ] = 0.0 else : accel [ i ] = self . A_MAX * ( 1 - ( self . v [ i ] / self . V0 ) ** 4 ) else : leader_idx = ( i - 1 + self . N ) % self . N gap = self . get_gap ( i , self . s ) accel [ i ] = self . idm_accel ( self . v [ i ], self . v [ leader_idx ], gap ) # Actualizar posiciones y velocidades (Euler) for i in range ( self . N ): if i == 0 and p0_is_stopped and v_new [ i ] == 0 : continue v_new [ i ] = max ( 0.0 , self . v [ i ] + accel [ i ] * self . DT ) s_new [ i ] = ( self . s [ i ] + v_new [ i ] * self . DT ) % self . CIRC # Regla anti-colisi\u00f3n if i != 0 : gap = self . get_gap ( i , self . s ) if ( v_new [ i ] * self . DT ) > ( gap - 0.5 ): v_new [ i ] = max ( 0.0 , ( gap - 0.5 ) / self . DT ) s_new [ i ] = ( self . s [ i ] + v_new [ i ] * self . DT ) % self . CIRC self . s = s_new self . v = v_new # VISUALIZACI\u00d3N def setup_draw ( self ): \"\"\" Inicializa la ventana y ejes de Matplotlib para la animaci\u00f3n. \"\"\" plt . ion () self . fig , self . ax = plt . subplots ( figsize = ( 7 , 7 )) def draw ( self , t ): \"\"\" Dibuja el estado actual de la simulaci\u00f3n: posiciones de veh\u00edculos, circuito circular y t\u00edtulo con tiempo. Args: t (float): Tiempo actual de la simulaci\u00f3n. \"\"\" R = self . CIRC / ( 2 * np . pi ) self . ax . clear () self . ax . set_box_aspect ( 1 ) self . ax . set_xlim ( - R * 1.3 , R * 1.3 ) self . ax . set_ylim ( - R * 1.3 , R * 1.3 ) self . ax . axis ( 'off' ) circle = plt . Circle (( 0 , 0 ), R , color = 'gray' , fill = False , linestyle = '--' , linewidth = 1.5 ) self . ax . add_artist ( circle ) angles = self . s / R X = R * np . cos ( angles ) Y = R * np . sin ( angles ) colors = [ 'blue' if i == 0 else '#d62728' for i in range ( self . N )] self . ax . scatter ( X , Y , s = 100 , c = colors , edgecolors = 'black' , zorder = 10 ) self . ax . set_title ( f \"Simulaci\u00f3n de Tr\u00e1fico \\n Tiempo: { t : .1f } s\" , fontsize = 14 ) plt . pause ( 0.001 ) # LOOP PRINCIPAL def run ( self ): \"\"\" Ejecuta el ciclo principal de la simulaci\u00f3n con visualizaci\u00f3n animada. - Inicializa la figura - Itera sobre la din\u00e1mica - Dibuja cada cierto n\u00famero de pasos - Finaliza mostrando la animaci\u00f3n detenida \"\"\" self . setup_draw () t = 0.0 print ( \"Iniciando simulaci\u00f3n...\" ) print ( f \"P0 frena a los { self . FIRST_STOP } s y cada { self . REPEAT_INTERVAL } s.\" ) while t < self . SIM_TIME : self . run_step ( t ) if int ( t / self . DT ) % 2 == 0 : self . draw ( t ) t += self . DT plt . ioff () plt . show ()","title":"Clase TrafficSimulation"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.A_MAX","text":"float: Aceleraci\u00f3n m\u00e1xima permitida.","title":"A_MAX"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.B_DECEL","text":"float: Desaceleraci\u00f3n c\u00f3moda.","title":"B_DECEL"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.CIRC","text":"float: Longitud total del circuito en metros.","title":"CIRC"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.DT","text":"float: Paso de tiempo de integraci\u00f3n (Euler).","title":"DT"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.FIRST_STOP","text":"float: Momento en que ocurre el primer frenazo.","title":"FIRST_STOP"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.L_VEHICLE","text":"float: Longitud de cada veh\u00edculo en metros.","title":"L_VEHICLE"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.N","text":"int: N\u00famero total de veh\u00edculos en el circuito.","title":"N"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.REPEAT_INTERVAL","text":"float: Intervalo entre frenazos consecutivos.","title":"REPEAT_INTERVAL"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.S0","text":"float: Distancia m\u00ednima permisible (jam distance).","title":"S0"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.SIM_TIME","text":"float: Tiempo total de simulaci\u00f3n en segundos.","title":"SIM_TIME"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.STOP_DURATION","text":"float: Duraci\u00f3n de cada frenazo del l\u00edder.","title":"STOP_DURATION"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.T_HEADWAY","text":"float: Tiempo de separaci\u00f3n deseado entre veh\u00edculos.","title":"T_HEADWAY"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.V0","text":"float: Velocidad deseada.","title":"V0"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.s","text":"np.ndarray: Posiciones iniciales sobre el circuito circular.","title":"s"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.v","text":"np.ndarray: Velocidades iniciales.","title":"v"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.__init__","text":"Inicializa los par\u00e1metros f\u00edsicos, modelo IDM, configuraci\u00f3n de frenazos del l\u00edder y el estado inicial de posiciones y velocidades. Source code in simulacionPoo.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def __init__ ( self ): \"\"\" Inicializa los par\u00e1metros f\u00edsicos, modelo IDM, configuraci\u00f3n de frenazos del l\u00edder y el estado inicial de posiciones y velocidades. \"\"\" # Par\u00e1metros Globales self . N = 22 \"\"\"int: N\u00famero total de veh\u00edculos en el circuito.\"\"\" self . CIRC = 230.0 \"\"\"float: Longitud total del circuito en metros.\"\"\" self . DT = 0.05 \"\"\"float: Paso de tiempo de integraci\u00f3n (Euler).\"\"\" self . SIM_TIME = 1200.0 \"\"\"float: Tiempo total de simulaci\u00f3n en segundos.\"\"\" # Par\u00e1metros F\u00edsicos self . L_VEHICLE = 4.0 \"\"\"float: Longitud de cada veh\u00edculo en metros.\"\"\" self . S0 = 2.0 \"\"\"float: Distancia m\u00ednima permisible (jam distance).\"\"\" # Modelo IDM self . V0 = 10.0 \"\"\"float: Velocidad deseada.\"\"\" self . A_MAX = 1.0 \"\"\"float: Aceleraci\u00f3n m\u00e1xima permitida.\"\"\" self . B_DECEL = 4.0 \"\"\"float: Desaceleraci\u00f3n c\u00f3moda.\"\"\" self . T_HEADWAY = 1.6 \"\"\"float: Tiempo de separaci\u00f3n deseado entre veh\u00edculos.\"\"\" # Eventos de parada del l\u00edder self . STOP_DURATION = 2.0 \"\"\"float: Duraci\u00f3n de cada frenazo del l\u00edder.\"\"\" self . FIRST_STOP = 2.0 \"\"\"float: Momento en que ocurre el primer frenazo.\"\"\" self . REPEAT_INTERVAL = 10.0 \"\"\"float: Intervalo entre frenazos consecutivos.\"\"\" # Estado inicial self . s = np . linspace ( 0 , self . CIRC , self . N , endpoint = False ) \"\"\"np.ndarray: Posiciones iniciales sobre el circuito circular.\"\"\" self . v = np . ones ( self . N ) * self . V0 \"\"\"np.ndarray: Velocidades iniciales.\"\"\" # Visualizaci\u00f3n self . fig , self . ax = None , None","title":"__init__"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.draw","text":"Dibuja el estado actual de la simulaci\u00f3n: posiciones de veh\u00edculos, circuito circular y t\u00edtulo con tiempo. Parameters: t ( float ) \u2013 Tiempo actual de la simulaci\u00f3n. Source code in simulacionPoo.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def draw ( self , t ): \"\"\" Dibuja el estado actual de la simulaci\u00f3n: posiciones de veh\u00edculos, circuito circular y t\u00edtulo con tiempo. Args: t (float): Tiempo actual de la simulaci\u00f3n. \"\"\" R = self . CIRC / ( 2 * np . pi ) self . ax . clear () self . ax . set_box_aspect ( 1 ) self . ax . set_xlim ( - R * 1.3 , R * 1.3 ) self . ax . set_ylim ( - R * 1.3 , R * 1.3 ) self . ax . axis ( 'off' ) circle = plt . Circle (( 0 , 0 ), R , color = 'gray' , fill = False , linestyle = '--' , linewidth = 1.5 ) self . ax . add_artist ( circle ) angles = self . s / R X = R * np . cos ( angles ) Y = R * np . sin ( angles ) colors = [ 'blue' if i == 0 else '#d62728' for i in range ( self . N )] self . ax . scatter ( X , Y , s = 100 , c = colors , edgecolors = 'black' , zorder = 10 ) self . ax . set_title ( f \"Simulaci\u00f3n de Tr\u00e1fico \\n Tiempo: { t : .1f } s\" , fontsize = 14 ) plt . pause ( 0.001 )","title":"draw"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.get_gap","text":"Calcula la distancia disponible entre el veh\u00edculo i y su l\u00edder. Parameters: i ( int ) \u2013 \u00cdndice del veh\u00edculo. s_curr ( ndarray ) \u2013 Vector actual de posiciones. Returns: float \u2013 Distancia libre efectiva al veh\u00edculo de adelante. Source code in simulacionPoo.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_gap ( self , i , s_curr ): \"\"\" Calcula la distancia disponible entre el veh\u00edculo `i` y su l\u00edder. Args: i (int): \u00cdndice del veh\u00edculo. s_curr (np.ndarray): Vector actual de posiciones. Returns: float: Distancia libre efectiva al veh\u00edculo de adelante. \"\"\" leader_idx = ( i - 1 + self . N ) % self . N dist = s_curr [ leader_idx ] - s_curr [ i ] if dist < 0 : dist += self . CIRC return dist - self . L_VEHICLE","title":"get_gap"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.idm_accel","text":"Calcula la aceleraci\u00f3n seg\u00fan el modelo IDM (Intelligent Driver Model). Parameters: v_curr ( float ) \u2013 Velocidad del veh\u00edculo actual. v_leader ( float ) \u2013 Velocidad del veh\u00edculo l\u00edder inmediato. gap ( float ) \u2013 Distancia libre al l\u00edder. Returns: float \u2013 Aceleraci\u00f3n resultante seg\u00fan el modelo. Source code in simulacionPoo.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def idm_accel ( self , v_curr , v_leader , gap ): \"\"\" Calcula la aceleraci\u00f3n seg\u00fan el modelo IDM (Intelligent Driver Model). Args: v_curr (float): Velocidad del veh\u00edculo actual. v_leader (float): Velocidad del veh\u00edculo l\u00edder inmediato. gap (float): Distancia libre al l\u00edder. Returns: float: Aceleraci\u00f3n resultante seg\u00fan el modelo. \"\"\" delta_v = v_curr - v_leader s_star = self . S0 + max ( 0.0 , v_curr * self . T_HEADWAY + ( v_curr * delta_v ) / ( 2 * math . sqrt ( self . A_MAX * self . B_DECEL )) ) effective_gap = max ( 0.01 , gap ) accel = self . A_MAX * ( 1 - ( v_curr / self . V0 ) ** 4 - ( s_star / effective_gap ) ** 2 ) return accel","title":"idm_accel"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.leader_stopped","text":"Determina si el veh\u00edculo l\u00edder debe estar detenido en el tiempo t . Los frenazos ocurren en: - FIRST_STOP - FIRST_STOP + REPEAT_INTERVAL - FIRST_STOP + 2*REPEAT_INTERVAL etc. Y duran STOP_DURATION segundos cada uno. Parameters: t ( float ) \u2013 Tiempo actual de la simulaci\u00f3n. Returns: bool \u2013 True si el l\u00edder debe estar frenando o detenido. Source code in simulacionPoo.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def leader_stopped ( self , t ): \"\"\" Determina si el veh\u00edculo l\u00edder debe estar detenido en el tiempo `t`. Los frenazos ocurren en: - FIRST_STOP - FIRST_STOP + REPEAT_INTERVAL - FIRST_STOP + 2*REPEAT_INTERVAL etc. Y duran STOP_DURATION segundos cada uno. Args: t (float): Tiempo actual de la simulaci\u00f3n. Returns: bool: True si el l\u00edder debe estar frenando o detenido. \"\"\" time_since_start = t - self . FIRST_STOP if time_since_start >= 0 : cycle_pos = time_since_start % self . REPEAT_INTERVAL return cycle_pos < self . STOP_DURATION return False","title":"leader_stopped"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.run","text":"Ejecuta el ciclo principal de la simulaci\u00f3n con visualizaci\u00f3n animada. Inicializa la figura Itera sobre la din\u00e1mica Dibuja cada cierto n\u00famero de pasos Finaliza mostrando la animaci\u00f3n detenida Source code in simulacionPoo.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def run ( self ): \"\"\" Ejecuta el ciclo principal de la simulaci\u00f3n con visualizaci\u00f3n animada. - Inicializa la figura - Itera sobre la din\u00e1mica - Dibuja cada cierto n\u00famero de pasos - Finaliza mostrando la animaci\u00f3n detenida \"\"\" self . setup_draw () t = 0.0 print ( \"Iniciando simulaci\u00f3n...\" ) print ( f \"P0 frena a los { self . FIRST_STOP } s y cada { self . REPEAT_INTERVAL } s.\" ) while t < self . SIM_TIME : self . run_step ( t ) if int ( t / self . DT ) % 2 == 0 : self . draw ( t ) t += self . DT plt . ioff () plt . show ()","title":"run"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.run_step","text":"Ejecuta un paso de simulaci\u00f3n: calcula aceleraciones, actualiza velocidades y posiciones, y aplica la regla anti-colisi\u00f3n. Parameters: t ( float ) \u2013 Tiempo actual. Source code in simulacionPoo.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def run_step ( self , t ): \"\"\" Ejecuta un paso de simulaci\u00f3n: calcula aceleraciones, actualiza velocidades y posiciones, y aplica la regla anti-colisi\u00f3n. Args: t (float): Tiempo actual. \"\"\" s_new = np . copy ( self . s ) v_new = np . copy ( self . v ) accel = np . zeros ( self . N ) p0_is_stopped = self . leader_stopped ( t ) # Calcular aceleraciones for i in range ( self . N ): if i == 0 : if p0_is_stopped : if self . v [ i ] > 0 : accel [ i ] = - 10.0 else : accel [ i ] = 0.0 v_new [ i ] = 0.0 else : accel [ i ] = self . A_MAX * ( 1 - ( self . v [ i ] / self . V0 ) ** 4 ) else : leader_idx = ( i - 1 + self . N ) % self . N gap = self . get_gap ( i , self . s ) accel [ i ] = self . idm_accel ( self . v [ i ], self . v [ leader_idx ], gap ) # Actualizar posiciones y velocidades (Euler) for i in range ( self . N ): if i == 0 and p0_is_stopped and v_new [ i ] == 0 : continue v_new [ i ] = max ( 0.0 , self . v [ i ] + accel [ i ] * self . DT ) s_new [ i ] = ( self . s [ i ] + v_new [ i ] * self . DT ) % self . CIRC # Regla anti-colisi\u00f3n if i != 0 : gap = self . get_gap ( i , self . s ) if ( v_new [ i ] * self . DT ) > ( gap - 0.5 ): v_new [ i ] = max ( 0.0 , ( gap - 0.5 ) / self . DT ) s_new [ i ] = ( self . s [ i ] + v_new [ i ] * self . DT ) % self . CIRC self . s = s_new self . v = v_new","title":"run_step"},{"location":"api/simulacion/#simulacionPoo.TrafficSimulation.setup_draw","text":"Inicializa la ventana y ejes de Matplotlib para la animaci\u00f3n. Source code in simulacionPoo.py 199 200 201 202 203 204 def setup_draw ( self ): \"\"\" Inicializa la ventana y ejes de Matplotlib para la animaci\u00f3n. \"\"\" plt . ion () self . fig , self . ax = plt . subplots ( figsize = ( 7 , 7 ))","title":"setup_draw"}]}